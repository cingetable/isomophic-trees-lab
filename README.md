# Изоморфизм деревьев
###### Баздуков В.А.



# Введение
В данной работе будет рассматриваться проблема изоморфизма деревьев. Основные идеи были взяты из книги Ахо А., Хопкрофта Дж., Ульмана Дж. "Построение и анализ вычислительных алгоритмов".

На практике алгоритм хорошо зарекомендовал себе в молекулярной химии, где зачастую изучаемые структуры представляют собой деревья с миллионами вершин. Таким образом задача проверки изоморфности двух структур сводится к проверке изоморфности двух деревьев.

# Теория
## Изоморфизм графов
Так как корневое дерево является частным случаем графа, то сначала стоит дать определение изоморфизма графов.

**Определение.** ***Изоморфизмом графов*** $G_{1}(V_{1},E_{1})$ и $G_{2}(V_{2},E_{2})$ называется биекция между наборами вершин $\varphi$: $V_{1} \rightarrow V_{2}$ такая что: 
$$\forall u,v \in V_{1} \quad (u,v) \in E_{1} \Leftrightarrow (\varphi(u), \varphi(v)) \in E_{2}$$ 
Выделяют несколько фактов об изоморфизме графов:
* До сих пор неизвестно, является ли алгоритм изоморфизма графов NP -- полной задачей.
* Существует алгоритм с полиноминальным временем для различных подмножеств графов, таких как деревья

## Корневые деревья

**Определение.** ***Корневое дерево*** **(V,E,***r***)** это дерево (V,E), в котором определен корень r $\in$ V.

**Определение.** ***Изоморфизмом корневых деревьев*** $T_{1}(V_{1},E_{1},r_{1})$ и $T_{2}(V_{2},E_{2},r_{2})$ называется биекция между наборами вершин $\varphi: V_{1} \leftarrow V_{2}$} такая что:
$$\forall(u,v)\in V_{1} \quad (u,v)\in E_{1} \Leftrightarrow (\varphi(u),\varphi(v)) \in E_{2}\quad \fbox{$\varphi(r_{1} = r_{2})$} $$

Так как корневые деревья дают нам гораздо больше информации о самих себя, нежели графы, то существует алгоритм, работающий за полиноминальное время.

# Алгоритм AHU

Данный алгоритм был разработан Ахо А. Хопкрофтом Дж., Ульман Дж. для определения изоморфности двух деревьев. 
	
У этого алгоритма есть 2 основных свойства:
* Определяет изоморфизм корневого дерева за O(|V|)
* Использует полную историю потомков степеней вершин в своей работе

**Основная идея алгоритма** состоит в том, чтобы связывать с каждой вершиной кортеж, который хранит полную историю его потомков, иначе говоря, ***сериализовать*** дерево. В свою очередь это обеспечивает детерминированный метод проверки изоморфизма дерева.

## Описание работы
Изоморфизм деревьев может быть найден следующим алгоритмом:
* Определить ***центр(-ы)*** деревьев
* Преобразовать оба дерева в ***корневые деревья***, где корень - центр дерева
* ***Сериализовать*** оба дерева. Если деревья изоморфны - результат сериализации будет идентичным.

### Диаметр и центр дерева

**Определение.** ***Диаметр дерева*** это длина самого длинного пути между его листьями.

**Определение.** Центром называется такая вершина $v$, что самый длинный путь от $v$ до листа минимален (половина диаметра).

Есть несколько способов найти центр дерева. В этой работе будет описан подход, который заключается в том чтобы итеративно отбирать каждый листовой узел, подобно "чистке лука"

**Определение.** ***Степень узла*** - это количество узлов, с которыми он связан.

Степень листовых узлов равна одному (по определению). 

После того, как алгоритм найдет все такие узлы, он удалит их из поиска, тем самым уменьшив степень всех смежных с листьями узлов на один. Далее алгоритм будет итеративно удалять новые листья до тех пор, пока не останется одна или две вершины. Эти самые вершины и будут центром(-ами) дерева.

```function treeCenters(g):
    n = g.numberOfNodes()
    degree = [0] * n
    leaves = []
    for(i=0; i<n; i++):
        if degree[i] == 0 or degree[i] == 1:
            leaves.add(i)
            degree[i] = 0
    count = leaves.size()
    
    while count < n:
        new_leaves = []
        for node in leaves:
            for neighbor in g[node]:
                degree[neighbor] = degree[neighbor] - 1
                if degree[neighbor] == 1:
                    new_leaves.add(neighbor)
        count += new_leaves.size()
        leaves = new_leaves
```
Параметр $g$ функции **treeCenters()** представляет собой неориентированный граф.

 Переменная $n$ представляет количество узлов в нашем дереве. Мы определили два массива, степень и листья. Первый имеет размер $n$ и хранит степень каждого узла в дереве, последний хранит самый последний слой конечных узлов. 
 
 Затем мы входим в цикл, где мы вычисляем степень каждого узла графа, также мы проверяем, рассматривается ли дерево с одним узлом или же листовой узел. Если какое-либо из этих условий выполняется, мы добавляем запись в массив листьев и помечаем ее значение в ***degrees array*** как 0, чтобы не посещать узел вновь. 
 
 Переменная $count$ будет отслеживать количество узлов, которые мы обработали на текущей итерации. Затем мы постоянно проверяем наличие листьев и удаляем их из поиска. 

## Сериализация дерева

Сериализованное представление дерево будет получено путем перевода его в уникальную кодировку, которая представляет собой последовательность открывающих и закрываюх скобок, например "(()()()(()))".  

Формальное описание работы:
* Присвоить всем листьям метку "()"
* Для каждого родителя объединить метки его детей и заключить в новую пару скобок.


Рассмотрим псевдокод:
```
function encode(node):
    if node == null:
        return ""
    labels = []
    for child in node.children():
        labels.add(encode(child))
    
    # lexographic sort
    sort(labels)

    result = ""
    for label in labels:
        result += label
    
    return "(" + result + ")"
```
Из основной программы в функцию передается центр дерева. Способ кодирования дерева с 2-мя центрами будет рассмотрен в след. главе.

Таким образом, если результат кодировки двух деревьев одинаков - деревья изоморфны.

## Проверка на изоморфизм при наличии двух центров

Отличие в кодировании дерева с 2-мя центрами заключается в том, что обозреваемое дерево разбивается на 2 поддерева, корнями которых являются оба центра. Все, что остается сделать в этом случае, это сравнить результат работы алгоритма для каждого из поддеревьев первого дерева со вторым. 

Псевдокод выглядит следующим образом:
```
function is_isomorphic(tree a, tree b):
    a_centers = find_centers(a)
    b_centers = find_centers(b)

    a_encoded = [encode(a, a_centers[0]), encode(a, a_centers[0])]
    b_encoded = [encode(b, b_centers[0]), encode(b, b_centers[0])]
    
    sort(a_encoded)
    sort(b_encoded)

    return a_encoded.ToString == b_encoded.ToString
```

Как видно из примера, алгоритм последовательно кодирует каждый центр каждого дерева, затем лексикографически сортирует результаты. Одинаковые кодировки соответствуют изоморфным деревьям.

# Реализация
# Тестирование
## Ручное тестирование
## Тестирование с использованием генератора
### Принцип работы генератора
#### Генерация дерева, изоморфного данному
### Анализ ассимптотики, с использованием ```<chrono>```

